import JSZip from 'jszip';
import { ProcessedFile } from '../types';

export class ZipService {
  async createZipFromFiles(files: ProcessedFile[], examCode: string): Promise<Blob> {
    const zip = new JSZip();
    
    // Create a folder for the exam
    const examFolder = zip.folder(examCode.toUpperCase());
    
    if (!examFolder) {
      throw new Error('Failed to create exam folder in ZIP');
    }

    let successCount = 0;
    let totalSize = 0;
    // Add each formatted file to the ZIP
    for (const file of files) {
      if (file.formattedFile && file.status === 'completed') {
        const fileName = file.newName;
        examFolder.file(fileName, file.formattedFile);
        successCount++;
        totalSize += file.formattedFile.size;
      }
    }

    if (successCount === 0) {
      throw new Error('No successfully processed files to include in ZIP');
    }
    // Add a README file with instructions
    const readmeContent = this.generateReadmeContent(files, examCode, successCount, totalSize);
    examFolder.file('README.txt', readmeContent);

    // Add a file list for easy reference
    const fileListContent = this.generateFileListContent(files);
    examFolder.file('FILE_LIST.txt', fileListContent);
    // Generate the ZIP file
    const zipBlob = await zip.generateAsync({
      type: 'blob',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 6
      }
    });

    console.log(`ZIP created successfully with ${successCount} files, total size: ${(zipBlob.size / 1024).toFixed(2)}KB`);
    return zipBlob;
  }

  private generateReadmeContent(files: ProcessedFile[], examCode: string, successCount: number, totalSize: number): string {
    const successfulFiles = files.filter(f => f.status === 'completed');
    const failedFiles = files.filter(f => f.status === 'error');

    let content = `${examCode.toUpperCase()} Document Conversion Results\n`;
    content += `Generated on: ${new Date().toLocaleString()}\n\n`;
    content += `Generated by: getConvertedExams.io\n`;
    
    content += `CONVERSION SUMMARY:\n`;
    content += `- Total files processed: ${files.length}\n`;
    content += `- Successfully converted: ${successCount}\n`;
    content += `- Failed conversions: ${failedFiles.length}\n`;
    content += `- Total size of converted files: ${(totalSize / 1024).toFixed(2)} KB\n\n`;
    
    content += `SUCCESSFULLY CONVERTED FILES (${successfulFiles.length}):\n`;
    content += '='.repeat(50) + '\n';
    
    successfulFiles.forEach((file, index) => {
      content += `${index + 1}. ${file.newName}\n`;
      content += `   Original: ${file.originalName}\n`;
      content += `   Type: ${file.detectedType}\n\n`;
      if (file.formattedFile) {
        content += `   Size: ${(file.formattedFile.size / 1024).toFixed(2)} KB\n`;
      }
    });

    if (failedFiles.length > 0) {
      content += `\nFAILED CONVERSIONS (${failedFiles.length}):\n`;
      content += '='.repeat(50) + '\n';
      
      failedFiles.forEach((file, index) => {
        content += `${index + 1}. ${file.originalName}\n`;
        content += `   Error: ${file.error || 'Unknown error'}\n\n`;
      });
    }

    content += '\nIMPORTANT NOTES:\n';
    content += '='.repeat(50) + '\n';
    content += '- All files have been formatted according to ' + examCode.toUpperCase() + ' specifications\n';
    content += '- Please verify file sizes and formats before uploading to the official portal\n';
    content += '- Keep original files as backup\n';
    content += '- Document names have been standardized for easy identification\n';
    content += '- All processing was done locally in your browser for privacy\n\n';
    
    content += 'EXAM-SPECIFIC REQUIREMENTS:\n';
    content += '='.repeat(50) + '\n';
    
    switch (examCode.toLowerCase()) {
      case 'upsc':
        content += '- Photo: 300x400px, JPEG, ≤200KB\n';
        content += '- Signature: 300x100px, JPEG, ≤50KB\n';
        content += '- Documents: PDF format, ≤500KB\n';
        break;
      case 'neet':
        content += '- Photo: 200x230px, JPEG, ≤100KB\n';
        content += '- Signature: 200x80px, JPEG, ≤30KB\n';
        content += '- Documents: JPEG format, ≤300KB\n';
        break;
      case 'jee':
        content += '- Photo: 240x320px, JPEG, ≤150KB\n';
        content += '- Signature: 240x80px, JPEG, ≤40KB\n';
        content += '- Documents: JPEG format, ≤400KB\n';
        break;
      case 'cat':
        content += '- Photo: 200x240px, JPEG, ≤120KB\n';
        content += '- Signature: 200x60px, JPEG, ≤25KB\n';
        content += '- Documents: PDF format, ≤600KB\n';
        break;
      case 'gate':
        content += '- Photo: 240x320px, JPEG, ≤100KB\n';
        content += '- Signature: 240x80px, JPEG, ≤30KB\n';
        content += '- Documents: JPEG format, ≤350KB\n';
        break;
    }
    
    content += '\nFor support or questions, visit: https://getconvertedexams.io\n';

    return content;
  }

  private generateFileListContent(files: ProcessedFile[]): string {
    let content = 'FILE CONVERSION DETAILS\n';
    content += '='.repeat(50) + '\n\n';
    
    files.forEach((file, index) => {
      content += `${index + 1}. ${file.originalName}\n`;
      content += `   Status: ${file.status.toUpperCase()}\n`;
      content += `   Detected Type: ${file.detectedType || 'Unknown'}\n`;
      content += `   New Name: ${file.newName || 'N/A'}\n`;
      content += `   Original Size: ${(file.file.size / 1024).toFixed(2)} KB\n`;
      
      if (file.formattedFile) {
        content += `   Final Size: ${(file.formattedFile.size / 1024).toFixed(2)} KB\n`;
        const compressionRatio = ((file.file.size - file.formattedFile.size) / file.file.size * 100);
        content += `   Compression: ${compressionRatio > 0 ? compressionRatio.toFixed(1) + '% reduced' : 'No compression'}\n`;
      }
      
      if (file.error) {
        content += `   Error: ${file.error}\n`;
      }
      
      content += '\n';
    });
    
    return content;
  }
}